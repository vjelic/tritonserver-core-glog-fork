{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-508455b2-c0fc-42f8-9e81-fda84cb0c3bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `total_byte_size` is larger than the size of `data_ptr`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (total_byte_size <= sizeof(data_ptr)) {\n    memcpy(data_ptr, file_input.data(), total_byte_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `total_byte_size` is less than or equal to the size of `data_ptr` before calling `memcpy`. If `total_byte_size` is larger, we handle the error appropriately instead of allowing a buffer overflow to occur.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9060e1d4-1353-4125-b6c5-788465312aa9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string, which can lead to buffer overflow. In the provided code example, if `ipAddress.c_str()` is longer than 15 characters, `strncpy` will not append a null character to `hostIpAddress`, potentially leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that automatically handle the null character, such as `strlcpy` or `snprintf`. If you must use `strncpy`, ensure that you manually append a null character to the destination string.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\nstrlcpy(hostIpAddress, ipAddress.c_str(), sizeof(hostIpAddress));\n```\n\nor\n\n```cpp\nsnprintf(hostIpAddress, sizeof(hostIpAddress), \"%s\", ipAddress.c_str());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `strncpy`, `strlcpy`, and `snprintf`\n- `<string>` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-5a6f55d7-ef77-4081-b9cc-5cca7a7ea116",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Avoid Leaving Debug Code in Production\" vulnerability in C++ arises when developers inadvertently leave debugging code, such as logging, assertions, or test hooks, in the production environment. This can lead to several issues, including performance degradation, information leakage, and unintended behavior. Debug code is typically meant for development and testing purposes and should be removed or disabled in production builds.\n\n### General Mitigation Advice\n\n1. **Code Review**: Conduct thorough code reviews to ensure that debug code is not present in production.\n2. **Build Configurations**: Use different build configurations for development and production. Ensure that debug code is only included in development builds.\n3. **Conditional Compilation**: Use preprocessor directives to include debug code only in non-production builds.\n4. **Automated Tools**: Utilize static analysis tools to detect and flag debug code in the codebase.\n\n### Source Code Fix Recommendation\n\nTo address the specific vulnerability sink `127.0.0.1`, ensure that any debug code related to network operations, such as connecting to localhost for testing, is removed or conditionally compiled out in production builds.\n\n#### Example Code\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Library dependencies\n#include <boost/asio.hpp>\n\nint main() {\n    // Debug code: connecting to localhost\n#ifdef DEBUG\n    std::string debug_ip = \"127.0.0.1\";\n    std::cout << \"Connecting to debug IP: \" << debug_ip << std::endl;\n    // Simulate network operation\n    boost::asio::io_context io_context;\n    boost::asio::ip::tcp::resolver resolver(io_context);\n    boost::asio::ip::tcp::resolver::query query(debug_ip, \"80\");\n    boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    // ... additional debug operations\n#endif\n\n    // Production code\n    std::cout << \"Running production code...\" << std::endl;\n    // ... production operations\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `boost/asio.hpp`: This library is required for network operations in the example code. Ensure that Boost is properly installed and linked in your project.\n\n### Relevant Links\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "glog-dd75caa6-480c-4923-b46d-5906351b04fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, the program should handle this condition gracefully, for example by allocating a larger buffer or by truncating the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (correlation_id_length <= sizeof(uint32_t)) {\n    memcpy(corrid_p_ptr + sizeof(uint32_t), correlation_id.c_str(), correlation_id_length);\n} else {\n    // Handle error condition, e.g. by truncating data or allocating a larger buffer\n}\n```\n\n## Library Dependencies\n\nThe provided code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cstdint>`: This library provides the `uint32_t` type.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-093aa409-67a9-46d1-9d36-8e49cacdbd05",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow or cause a system crash (Denial of Service attacks).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. \n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `strncpy` or `memcpy_s`. If using `memcpy_s`, the code would look like this:\n\n```cpp\nif (corrid_p_ptr != NULL && corrid_ptr != NULL && size_p <= sizeof(corrid_p_ptr)) {\n    memcpy_s(corrid_p_ptr, size_p, corrid_ptr, size_p);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so it does not require any additional libraries. However, if you choose to use `memcpy_s`, it is part of the optional Annex K in C11 standard, and may not be available in all C standard libraries.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2ace0184-be36-4962-aefd-f8eacdccb7e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to various vulnerabilities if not used properly. The most common vulnerability is a buffer overflow, which occurs when the size of the data being copied exceeds the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unexpected behavior, including program crashes, data corruption, and execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix the vulnerability in the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dst, size_t dst_size, const void* src, size_t byte_size) {\n    if (dst_size >= byte_size) {\n        memcpy(dst, src, byte_size);\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\nIn this example, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the copy operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3c3698a8-9062-46b2-bf89-b4b764d85b32",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is copying the size of `uint32_t` (which is 4 bytes) from the address of `correlation_id_length` to `corrid_p_ptr`. If `corrid_p_ptr` is not large enough to hold 4 bytes, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the copied data. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nuint32_t buffer_size = sizeof(corrid_p_ptr);\nif (buffer_size >= sizeof(uint32_t)) {\n    memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if `corrid_p_ptr` is large enough to hold `uint32_t`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5e9d39e2-c1e2-49e9-a713-30072fd164f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Issue Detected with C Function (strlen)\" refers to the misuse of the `strlen` function in the C++ programming language. The `strlen` function is used to calculate the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. In the provided code snippet, `strlen(\"http://\")`, there is no direct vulnerability as the string is a constant. However, if the string was replaced with a variable that could be manipulated by an attacker, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that limit the size of the input, such as `strnlen` or `strncpy`. These functions take an additional parameter that specifies the maximum number of characters to be copied or measured, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `strlen` with `strnlen`:\n\n```cpp\n#include <string.h>\n\nconst char* url = \"http://\";\nsize_t url_length = strnlen(url, 100); // 100 is an example, replace with the actual maximum expected length\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-508455b2-c0fc-42f8-9e81-fda84cb0c3bc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 459,
                  "startColumn": 6,
                  "endLine": 459,
                  "endColumn": 58,
                  "charOffset": 16356,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(data_ptr, file_input.data(), total_byte_size)",
                    "rendered": {
                      "text": "memcpy(data_ptr, file_input.data(), total_byte_size)",
                      "markdown": "`memcpy(data_ptr, file_input.data(), total_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16356,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data_ptr, <size of data_ptr>,  file_input.data(),  total_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9060e1d4-1353-4125-b6c5-788465312aa9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/metrics.cc"
                },
                "region": {
                  "startLine": 791,
                  "startColumn": 4,
                  "endLine": 791,
                  "endColumn": 49,
                  "charOffset": 28641,
                  "charLength": 45,
                  "snippet": {
                    "text": "strncpy(hostIpAddress, ipAddress.c_str(), 15)",
                    "rendered": {
                      "text": "strncpy(hostIpAddress, ipAddress.c_str(), 15)",
                      "markdown": "`strncpy(hostIpAddress, ipAddress.c_str(), 15)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/metrics.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28641,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(hostIpAddress,  15,  ipAddress.c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/metrics.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28641,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(hostIpAddress,  ipAddress.c_str(),  15)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5a6f55d7-ef77-4081-b9cc-5cca7a7ea116",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Avoid Leaving Debug Code in Production"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/metrics.cc"
                },
                "region": {
                  "startLine": 790,
                  "startColumn": 29,
                  "endLine": 790,
                  "endColumn": 38,
                  "charOffset": 28625,
                  "charLength": 9,
                  "snippet": {
                    "text": "127.0.0.1",
                    "rendered": {
                      "text": "127.0.0.1",
                      "markdown": "`127.0.0.1`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "glog-dd75caa6-480c-4923-b46d-5906351b04fd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1381,
                  "startColumn": 6,
                  "endLine": 1383,
                  "endColumn": 32,
                  "charOffset": 52581,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(\n          corrid_p_ptr + sizeof(uint32_t), correlation_id.c_str(),\n          correlation_id_length)",
                    "rendered": {
                      "text": "memcpy(\n          corrid_p_ptr + sizeof(uint32_t), correlation_id.c_str(),\n          correlation_id_length)",
                      "markdown": "`memcpy(\n          corrid_p_ptr + sizeof(uint32_t), correlation_id.c_str(),\n          correlation_id_length)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52581,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          corrid_p_ptr + sizeof(uint32_t), <size of \n          corrid_p_ptr + sizeof(uint32_t)>,  correlation_id.c_str(), \n          correlation_id_length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-093aa409-67a9-46d1-9d36-8e49cacdbd05",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1388,
                  "startColumn": 6,
                  "endLine": 1388,
                  "endColumn": 46,
                  "charOffset": 52925,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(corrid_p_ptr, corrid_ptr, size_p)",
                    "rendered": {
                      "text": "memcpy(corrid_p_ptr, corrid_ptr, size_p)",
                      "markdown": "`memcpy(corrid_p_ptr, corrid_ptr, size_p)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52925,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(corrid_p_ptr, <size of corrid_p_ptr>,  corrid_ptr,  size_p)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ace0184-be36-4962-aefd-f8eacdccb7e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cuda_utils.cc"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 6,
                  "endLine": 148,
                  "endColumn": 33,
                  "charOffset": 5035,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_size)",
                      "markdown": "`memcpy(dst, src, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cuda_utils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5035,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3c3698a8-9062-46b2-bf89-b4b764d85b32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1380,
                  "startColumn": 6,
                  "endLine": 1380,
                  "endColumn": 67,
                  "charOffset": 52511,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)",
                      "markdown": "`memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52511,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(corrid_p_ptr, <size of corrid_p_ptr>,  &correlation_id_length,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5e9d39e2-c1e2-49e9-a713-30072fd164f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 38,
                  "endLine": 235,
                  "endColumn": 55,
                  "charOffset": 9095,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(\"http://\")",
                    "rendered": {
                      "text": "strlen(\"http://\")",
                      "markdown": "`strlen(\"http://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9095,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"http://\", <size of \"http://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9095,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(\"http://\", <size of \"http://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}