{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "0f0b9a5d-fa44-3798-b430-9b90a3587522",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this specific case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is stored in environment block associated with the current process. If the environment variable is changed, the string can also be changed, leading to potential security issues.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, use secure alternatives that are provided by the platform. For example, in Windows, use `GetEnvironmentVariable` function. In Unix-based systems, use `getenv_r` or `secure_getenv` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `std::getenv` function with a secure alternative. For example:\n\n```cpp\nchar *secure_variable;\n#ifdef _WIN32\n    DWORD dwRet;\n    TCHAR lpBuffer[BUFSIZE];\n    dwRet = GetEnvironmentVariable(TEXT(\"TRITON_CLOUD_CREDENTIAL_PATH\"), lpBuffer, BUFSIZE);\n    if( dwRet == 0 )\n        printf(\"GetEnvironmentVariable failed (%d)\\n\", GetLastError());\n    else if( dwRet > BUFSIZE )\n        printf(\"Buffer too small, need size %d\\n\", dwRet);\n    else\n        secure_variable = lpBuffer;\n#else\n    secure_variable = getenv_r(\"TRITON_CLOUD_CREDENTIAL_PATH\");\n#endif\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `std::getenv`\n- `<windows.h>` for `GetEnvironmentVariable` on Windows\n- `<unistd.h>` for `getenv_r` on Unix-based systems\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ac428da8-26f9-3120-8f65-d1c61ecedbdb",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis observed that the source and destination may be aliases of each other, which can lead to unpredictable results when using memory copy operations like memcpy. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is not likely to be null, but the source may be, and there is no explicit check for this. The count argument is not derived from a known safe capacity, and there are no additional safety checks present. All these factors contribute to a high confidence in the finding's validity.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nstd::memmove(new_base, base, byte_size);\n```\n\nAdditionally, ensure that both `new_base` and `base` are not null before performing the operation:\n\n```cpp\nif (new_base != nullptr && base != nullptr) {\n    std::memmove(new_base, base, byte_size);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b1eea13c-2a23-36d4-a6ef-56eda3e97361",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using functions like memcpy. Additionally, the source may be null, which further increases the risk of runtime errors. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly derived from a known safe capacity. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential security and stability problems.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `std::memmove` instead of `std::memcpy`. `std::memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nstd::memmove(cache_buffer, buffers_[i].data(), cache_buffer_size);\n```\n\nAdditionally, ensure that `cache_buffer_size` does not exceed the actual size of either buffer to prevent buffer overflows. If possible, add checks to verify that both source and destination pointers are valid and that the size is within bounds before performing the copy.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "17f13493-cac7-32e0-bef8-ea33b778356a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable: malloc result used without null check (possible null deref)', and the call verdict is 'GENUINE'. The code allocates memory using malloc with a non-literal, unchecked size expression (byte_size), and the result is assigned to new_base. The first use of the pointer is as a destination in a memcpy call, and there is no null guard before this use. This means that if malloc fails and returns NULL, the subsequent memcpy will dereference a null pointer, leading to undefined behavior or a crash. There are no zero guards or overflow guards present, and the pointer is not checked for NULL before use. These factors indicate a genuine risk of null dereference after failed allocation.\n\n## In Context Remediation\nTo prevent a null pointer dereference after a failed memory allocation, always check the result of malloc before using the allocated memory. For example, after:\n\n```c\nnew_base = malloc(byte_size);\n```\nadd a null check before using new_base:\n\n```c\nnew_base = malloc(byte_size);\nif (new_base == NULL) {\n    // Handle allocation failure, e.g., return an error or clean up\n    return TRITONCACHE_STATUS_ALLOC_FAILED;\n}\n// Safe to use new_base, e.g., as memcpy destination\n```\nThis ensures that if malloc fails, the code does not proceed to use a null pointer, preventing undefined behavior or crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "d5a8c098-59d3-3d1a-8f13-5584fb992669",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings to not accidentally overwrite the null terminator. When dealing with user input or other untrusted data, always check the length of the data and ensure it fits within your buffer before copying it.\n\n## Source Code Fix Recommendation\n\nIf `dtype` is a string that you are reading, you should ensure it is null-terminated before calling `strlen`. If you are not sure if it is null-terminated, you can use `strnlen` instead, which takes a maximum length as a second argument:\n\n```cpp\nsize_t len = strnlen(dtype, MAX_LENGTH);\n```\n\nReplace `MAX_LENGTH` with the maximum length `dtype` should have. This will prevent `strnlen` from reading beyond this length, even if it doesn't find a null character.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a7c32d79-d161-3975-a0f8-fcf4e2823ab3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is stored in an environment block. The problem is that the returned string can be overwritten by subsequent calls to `std::getenv`, `std::setenv`, or `std::putenv`.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, use secure alternatives that are thread-safe and do not have the risk of being overwritten. If you must use environment variables, consider using a method that copies the value out immediately, rather than relying on the pointer.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar* value = std::getenv(\"AZURE_STORAGE_ACCOUNT\");\nif (value != nullptr) {\n    std::string account_str(value);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "247eb5c9-0dad-379e-9c46-f81d4136f23d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is stored in environment variable. If the environment variable is changed, the string can also be changed, leading to potential security issues.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, use secure alternatives that are provided by the platform. For example, in Windows, you can use `GetEnvironmentVariable` function. Also, always validate and sanitize the input and output data.\n\n## Source Code Fix Recommendation\n\nInstead of using `std::getenv`, use a secure alternative. Here is an example of how you can do it in Windows:\n\n```cpp\nchar account_key[100];\nGetEnvironmentVariable(\"AZURE_STORAGE_KEY\", account_key, 100);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `std::getenv` function)\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "47f78bec-7597-3cf5-ad83-75bdd6d1d4a3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. In this case, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv()` function directly. Instead, use safer alternatives that limit the potential for buffer overflows and other vulnerabilities. Validate all input and do not trust the data obtained from `getenv()` function without validation. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv()`, consider using a safer alternative. For example, you can use the `std::getenv()` function from the C++ standard library, which is considered safer:\n\n```cpp\n#include <cstdlib>\n\nstd::string variable_name = \"VAR_NAME\";\nchar* value;\nif((value = std::getenv(variable_name.c_str())) != nullptr) {\n    // Use the value\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This is a C++ standard library that provides general purpose functions including the safer `std::getenv()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4f3903aa-aff0-343e-86b6-b4065c27ad01",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The code uses a memory copy function with source and destination pointers that may refer to overlapping memory areas, as indicated by the dataflow analysis. This can result in unpredictable program behavior, data corruption, or crashes. The source and destination are both pointers, and there is no evidence of explicit checks or guards to prevent overlap. Additionally, the function used is not safe for overlapping regions. The analysis also confirms that neither the source nor the destination is null at the call site, so the main risk is the potential for overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` correctly handles overlapping memory areas.\n\n**Remediation Example:**\n\n```c\n// Replace this:\nmemcpy(dst, src, byte_size);\n\n// With this:\nmemmove(dst, src, byte_size);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3abb514d-ffea-3c22-bab6-2b2809839c3c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `std::atoll()` is used, which converts a C-string to a long long integer. This function does not perform any error checking, so if the string does not represent a valid number, the behavior is undefined, potentially leading to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform error checking. In C++, this can be achieved by using string streams or the `std::stoll()` function, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nHere is a safer alternative using `std::stoll()`:\n\n```cpp\n#include <string>\n#include <stdexcept>\n\nlong long d;\nstd::string str;\n\ntry {\n    d = std::stoll(str);\n} catch (std::invalid_argument const &e) {\n    // Handle the case where 'str' does not represent a valid number\n} catch (std::out_of_range const &e) {\n    // Handle the case where the conversion resulted in overflow\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::string` and `std::stoll()`\n- `<stdexcept>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "768ee474-8462-3af4-af46-588e3407c16c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `std::atoll()` is used, which converts a C-string to a long long integer. This function does not perform any error checking, so if the string does not represent a valid number, the behavior is undefined, potentially leading to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform error checking. In C++, this can be achieved by using string streams or the `std::stoll()` function, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nHere is a safer alternative using `std::stoll()`:\n\n```cpp\n#include <string>\n#include <stdexcept>\n\nlong long d;\nstd::string str;\n\ntry {\n    d = std::stoll(str);\n} catch (std::invalid_argument const &e) {\n    // Handle the case where 'str' does not represent a valid number\n} catch (std::out_of_range const &e) {\n    // Handle the case where the conversion resulted in overflow\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::string` and `std::stoll()`\n- `<stdexcept>`: for `std::invalid_argument` and `std::out_of_range`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e5b99c3c-cb9c-3d7f-a613-1e0590355146",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash the program, or code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)\n```\n\nThe vulnerability arises if `copy_params->byte_size_` is larger than the size of `copy_params->dst_`. This can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(copy_params->dst_) >= copy_params->byte_size_) {\n    memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_);\n} else {\n    // Handle the error, e.g., by logging it or throwing an exception.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "423dab50-0843-3d87-981e-682835760399",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to serious vulnerabilities if not used properly. The most common vulnerability associated with `memcpy` is buffer overflow. This happens when the size of the data being copied exceeds the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior, including memory corruption, crashes, and other security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Also, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t byte_size) {\n    if (byte_size > dst_size) {\n        // Handle the error, e.g.:\n        throw std::length_error(\"Source size exceeds destination size\");\n    }\n    memcpy(dst, src, byte_size);\n}\n```\n\nIn this code, we first check if the size of the data being copied is greater than the size of the destination buffer. If it is, we throw an exception. Otherwise, we proceed with the `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "35a89f78-59a8-385d-be57-547aaf60e904",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. These functions are often prohibited in secure coding standards due to their inherent risks. In the provided code snippet, the function `std::atoll()` is used, which can lead to potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these prohibited C functions. In the case of `std::atoll()`, it is better to use `std::stoll()` or `std::strtoll()`, which are safer as they can handle errors more gracefully.\n\n## Source Code Fix Recommendation\n\nReplace the `std::atoll()` function with `std::stoll()` or `std::strtoll()`. Here is how you can do it:\n\n```cpp\ntry {\n    version = std::stoll(version_dir);\n} catch (std::invalid_argument const &e) {\n    // Handle the case when the string cannot be converted to a number\n} catch (std::out_of_range const &e) {\n    // Handle the case when the number is too large for the long long type\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::string` type.\n- `<cstdlib>`: for `std::atoll()` function.\n- `<stdexcept>`: for `std::invalid_argument` and `std::out_of_range` exceptions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4cf5cf17-3707-35dc-86e5-3c50816fad30",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Code Debugging Vulnerability\" in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or turn off the debugging mode before deploying the application.\n2. Use preprocessor directives to ensure that debugging code is not included in the production build.\n3. Regularly use code review processes to catch any debugging code that might have been left in the production code.\n4. Use automated tools to scan for common debugging functions and commands.\n\n## Source Code Fix Recommendation\n\nAssuming the debugging code is something like this:\n\n```cpp\nipAddress = \"127.0.0.1\";\nstd::cout << \"Debug: IP Address is \" << ipAddress << std::endl;\n```\n\nThe recommended fix would be to remove the debugging line or wrap it with a preprocessor directive:\n\n```cpp\nipAddress = \"127.0.0.1\";\n#ifdef DEBUG\nstd::cout << \"Debug: IP Address is \" << ipAddress << std::endl;\n#endif\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library:\n\n- iostream\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "c1262fae-3866-3816-952c-00b6660ac02b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to ensure the source is non-null, which increases the risk of a runtime error. The destination is not likely to be null, but the source may be, further increasing the risk. The use of a raw memory copy function without explicit overlap checks or guarantees can lead to unpredictable program behavior, data corruption, or crashes. This issue should be addressed to ensure safe and correct memory operations.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely.\n\n```cpp\nmemmove(&output_byte_size, packed_bytes.begin() + position, sizeof(uint64_t));\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid potential null pointer dereference:\n\n```cpp\nif (packed_bytes.begin() + position != nullptr) {\n    memmove(&output_byte_size, packed_bytes.begin() + position, sizeof(uint64_t));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c6afa829-0e06-320e-bc08-eaba33ba960d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is associated with the matched environment variable name. If the environment variable is not found, it returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables. Always validate and sanitize input from all untrusted data sources.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar* value = std::getenv(\"TRITON_SERVER_CPU_ONLY\");\nif(value == nullptr) {\n    // Handle the error, e.g., by throwing an exception, returning, etc.\n    throw std::runtime_error(\"Environment variable not found\");\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "eefd14e7-3473-36dc-b594-c54371548437",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is stored in an environment variable. If the environment variable is changed, the pointer returned by `std::getenv` may become invalid.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function as it can lead to security vulnerabilities. Instead, use secure alternatives that are provided by the C++ Standard Library. If you must use `std::getenv`, ensure that the environment variable is not changed during the execution of your program.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar* value;\nif ((value = std::getenv(\"TRITON_PARALLEL_INSTANCE_LOADING\")) != NULL) {\n    env = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This library is required for the `std::getenv` function.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8e4befe9-44eb-3173-bc42-1479b0cf4062",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which increases the risk of null pointer dereference. No explicit bounds or capacity checks are present, and the count argument is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a memory move function that is safe for overlapping regions. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (shape.data() != nullptr && packed_bytes.begin() + position != nullptr && shape.data() != packed_bytes.begin() + position) {\n    memcpy(shape.data(), packed_bytes.begin() + position, shape_byte_size);\n}\n```\n\nIf overlap between source and destination is possible, replace the copy function with a move function:\n\n```cpp\nif (shape.data() != nullptr && packed_bytes.begin() + position != nullptr) {\n    memmove(shape.data(), packed_bytes.begin() + position, shape_byte_size);\n}\n```\n\nAlways validate that the size of the destination buffer is sufficient for the number of bytes being copied to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b5dda9af-9cf3-3e32-afa0-08dc5fb06369",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source pointer is not null, which further increases the risk. The destination is not a pointer-based member, so it is less likely to be null, but the source may be. The operation copies a fixed number of bytes (the size of a 32-bit unsigned integer), but this does not mitigate the risk of undefined behavior if the memory regions overlap. The verdict is supported by the classification and the call site verdict, both indicating a high-confidence issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\nif (packed_bytes.begin() != nullptr) {\n    memmove(&shape_byte_size, packed_bytes.begin() + position, sizeof(uint32_t));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures that the operation is safe even if the memory regions overlap and prevents undefined behavior due to null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "647fa7b4-45fb-375c-bf40-0ed7c47ef84e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a 'UB Risk' (undefined behavior risk) due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can lead to undefined behavior in C/C++ when using functions like memcpy. Additionally, the source pointer may be null at this call site, as there is no prior check ensuring it is non-null, further increasing the risk. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit bounds or guards are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions, ensure that the source and destination memory areas do not overlap before calling the memory copy function. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\nif (packed_bytes.begin() + position != (uint8_t*)&name_byte_size && packed_bytes.begin() + position != nullptr) {\n    memcpy(&name_byte_size, packed_bytes.begin() + position, sizeof(uint32_t));\n} else if (packed_bytes.begin() + position == (uint8_t*)&name_byte_size) {\n    // If overlap is possible, use memmove instead\n    memmove(&name_byte_size, packed_bytes.begin() + position, sizeof(uint32_t));\n}\n```\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d8b6581e-3d77-348c-b036-21405f882b9f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions. The analysis detected that the memory areas used in the copy operation may overlap, which can cause undefined behavior when using functions like memcpy. Additionally, there is a risk that the source pointer could be null at this point in the code, as there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a serious issue. No explicit bounds or guards are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&dtype_byte_size, packed_bytes.begin() + position, sizeof(uint32_t));\n```\n\nAdditionally, ensure that the source pointer (`packed_bytes.begin() + position`) is not null before performing the copy. You can add a check like:\n\n```cpp\nif (packed_bytes.begin() != nullptr && position < packed_bytes.size()) {\n    memmove(&dtype_byte_size, packed_bytes.begin() + position, sizeof(uint32_t));\n}\n```\n\nThis ensures both safe copying and avoids dereferencing a null pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "29bd8595-b1ce-3a8c-acf7-8c4a0937ccb5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the primary concern is the potential for undefined behavior due to overlapping memory regions. No explicit length or capacity checks are present, and the count argument is not derived from a known safe source. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use a memory copy function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, ensure that the source pointer is not null before performing the copy. For example:\n\n```cpp\nif (cache_output.buffer_ != nullptr) {\n    memmove(output_buffer, cache_output.buffer_, cache_output.byte_size_);\n}\n```\nThis change ensures that the copy operation is safe even if the memory regions overlap, and avoids dereferencing a null pointer.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3daacc22-6872-3335-bbcc-052bb7f2cf5f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states a risk of undefined behavior. The analysis detected that the destination and source may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null at this location, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the destination is not a pointer-based member, making it less likely to be protected by other means. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `std::memmove` instead of `std::memcpy`. `std::memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nstd::memmove(&packed_output_size, base + position, sizeof(packed_output_size));\n```\n\nThis change ensures that even if the source and destination overlap, the operation will be performed correctly and safely.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0e0cc587-b1f9-39ec-8e5f-ea490eae15f3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions like memcpy. There are no guards or checks in place to prevent this overlap, and neither the source nor the destination is null at the call site, so the main concern is the potential for overlapping memory regions. This type of issue can lead to data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely.\n\n**Remediation Example:**\n\n```cpp\nstd::memmove(&num_outputs, base, sizeof(num_outputs));\n```\n\nThis change ensures that even if the source and destination memory regions overlap, the copy will be performed correctly and safely, avoiding undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d9a1e8fd-53e2-3bda-9ef9-e7c581c51bc2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results when using memory copy functions that do not support overlapping regions. There are no indications that the source or destination pointers are null at the call site, and there are no explicit bounds or guards ensuring safe operation. The destination buffer's capacity is not known, and the length argument is not derived from the buffer's size, further increasing the risk. This issue should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original memory copy call with `memmove` to ensure correct behavior even if the regions overlap.\n\n```cpp\nmemmove(buffer + position, output_base, u64_output_byte_size);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ff0d165a-b7ba-3fdb-bb8d-8d4db2e45c5f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states there is a risk of undefined behavior. The analysis determined that overlap is feasible based on data flow from the destination to the source, which can cause issues with functions like memcpy that do not support overlapping regions. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using memcpy. If there is any possibility of overlap, use memmove instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(buffer + position, &u64_output_byte_size, sizeof(uint64_t));\n```\n\nAdditionally, verify that both the source and destination pointers are valid and not null before performing the copy. This can be done with explicit checks:\n\n```cpp\nif ((buffer != nullptr) && (&u64_output_byte_size != nullptr)) {\n    memmove(buffer + position, &u64_output_byte_size, sizeof(uint64_t));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "43d98d3a-a370-339c-ab19-f30719a6bcdc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks are both present. No explicit bounds checks or guards are present, and the size of the copy is not derived from the destination's capacity, increasing the risk of memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(buffer + position, shape.data(), shape_byte_size);\n```\n\nAdditionally, ensure that `shape.data()` is not null before performing the copy to avoid a possible null pointer dereference:\n\n```cpp\nif (shape.data() != nullptr) {\n    memmove(buffer + position, shape.data(), shape_byte_size);\n}\n```\n\nIf you know that overlap is not possible, document this assumption clearly in the code and consider adding an assertion:\n\n```cpp\nassert(buffer + position != shape.data());\nmemcpy(buffer + position, shape.data(), shape_byte_size);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "43a67c7f-e15f-35fb-8b54-8b664164a473",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as genuine, and the classification specifically highlights undefined behavior risk. The analysis determined that the destination and source may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, the source may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards to prevent these issues, and the destination buffer's capacity is not verified. These factors indicate a real and actionable security or correctness issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use a function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, verify that the source pointer is not null before performing the copy operation. For example:\n\n```cpp\nif (&shape_byte_size != buffer + position && &shape_byte_size != nullptr) {\n    memmove(buffer + position, &shape_byte_size, sizeof(uint32_t));\n}\n```\n\nThis change ensures that the copy is performed safely even if the memory regions overlap, and it avoids undefined behavior if the source is null. Always validate pointers and consider the possibility of overlap when using low-level memory functions.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "37906f89-1e7c-31d5-a8ba-66718f028ac6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, the source pointer may be null in some cases, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the source pointer is not null before performing the copy operation.\n\n```cpp\nif (&dtype_byte_size != buffer + position && &dtype_byte_size != nullptr) {\n    memcpy(buffer + position, &dtype_byte_size, sizeof(uint32_t));\n} else if (&dtype_byte_size == buffer + position) {\n    // If overlap is possible, use memmove\n    memmove(buffer + position, &dtype_byte_size, sizeof(uint32_t));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "935e479b-81ac-3824-8f05-587643c1b22e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow between the destination and source, which can cause unpredictable results with functions like memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination is not confirmed to be a pointer-based member, but overlap remains possible. These factors indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions, ensure that the source and destination memory areas do not overlap before calling the memory copy function. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(buffer + position, &name_byte_size, sizeof(uint32_t));\n```\n\nAlternatively, add explicit checks to guarantee that the source and destination do not overlap, or refactor the code to avoid such situations entirely. Always validate that the source pointer is not null before performing the copy to prevent null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e15baff6-b7ee-378e-a25f-0fb03c347845",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow from the destination to the source, which can cause unpredictable results with functions like memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit guards or checks to prevent these issues, and the destination is not confirmed to be a safe, non-overlapping buffer. These factors together indicate a real risk of memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use a function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(buffer + position, &total_byte_size, sizeof(uint64_t));\n```\n\nAdditionally, verify that both the source and destination pointers are valid and not null before performing the copy. This helps prevent crashes due to null pointer dereferencing.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "268fe16b-c065-3049-bd96-5c4a95b535b7",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit guards or checks to prevent these issues, and the verdict confirms this is a genuine issue. The destination is a pointer type, and the copy size is fixed, but the potential for overlap and null source makes this a high-confidence finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `std::memmove` instead of `std::memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nstd::memmove(base, &num_outputs, sizeof(uint32_t));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. You can add checks like:\n\n```cpp\nif (base != nullptr && &num_outputs != nullptr) {\n    std::memmove(base, &num_outputs, sizeof(uint32_t));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ee4a4bc5-8bac-376f-b1cf-830b27ac4e47",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash. The function used for copying does not handle overlapping memory regions safely, and the absence of explicit size checks or overlap prevention further increases the risk. This type of issue can result in unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(dst_buffer, initial_state_buffer, initial_state_it->second.data_->TotalByteSize());\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (dst_buffer != nullptr && initial_state_buffer != nullptr) {\n    memmove(dst_buffer, initial_state_buffer, initial_state_it->second.data_->TotalByteSize());\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f7383f15-545d-3fda-b8a1-dbdaf8a69f67",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to buffer overflow vulnerabilities if not used carefully. This is because `strlen` does not check for the null character at the end of the string, and if it is not present, `strlen` will continue reading memory until it finds one, potentially leading to a buffer overflow.\n\nIn the provided code snippet, the `strlen` function is used to calculate the length of a hardcoded string \"gs://\". This usage is not directly vulnerable as the string is hardcoded and null-terminated. However, if the string was replaced with a variable that might not be null-terminated, it could lead to a vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include a length parameter. This length parameter can be used to specify the maximum number of characters to be processed, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn this specific case, since the string is hardcoded, there is no direct vulnerability. However, if the string was replaced with a variable, the following code could be used to prevent potential vulnerabilities:\n\n```cpp\nstd::string str = \"gs://\";\nbucket_start = path.find(str) + str.length();\n```\n\nIn this code, the `length` function of the `std::string` class is used instead of `strlen`. This function returns the number of characters in the string, and it does not rely on the presence of a null character.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "316ba1ed-468f-3afb-823e-138611db3b0c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to a string that is stored in an environment block. The problem is that the returned pointer can be invalidated or the string content can be overwritten by another thread.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, use safer alternatives that are thread-safe and do not have the same vulnerabilities. In C++, you can use the `std::get` function from the `std` library, which is a safer alternative.\n\n## Source Code Fix Recommendation\n\nInstead of using `std::getenv`, you can use `std::get` function. Here is how you can do it:\n\n```cpp\n#include <cstdlib>\n\nconst char* path = std::getenv(\"GOOGLE_APPLICATION_CREDENTIALS\");\nif (!path) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## OWASP and CWE Resources\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6dd3286c-fb15-37f0-bf22-4ee147ae99e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function as it does not check for errors. It is recommended to use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for strtol\n#include <climits> // for LONG_MAX and LONG_MIN\n#include <cerrno>  // for errno\n\nchar *end;\nlong delay_cnt = strtol(dstr, &end, 10);\n\nif (end == dstr) {\n    // dstr is empty or invalid number\n} else if ((delay_cnt == LONG_MAX || delay_cnt == LONG_MIN) && errno == ERANGE) {\n    // delay_cnt is out of range\n} else {\n    // delay_cnt is valid\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4fcab61e-7d1f-3e2b-882a-c9bc956dd491",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the function `getenv()` is used, which can lead to security vulnerabilities as it allows access to the environment variables of the process. An attacker could potentially manipulate these variables to influence the program behavior.\n\n## Mitigation Advice\n\nAvoid using functions that can lead to security vulnerabilities. In this case, consider using a safer alternative to `getenv()`. If you must use `getenv()`, ensure that the environment in which your application runs is secure and that environment variables cannot be manipulated by untrusted users.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your application. If you need to access an environment variable, you could consider using a safer alternative like `std::getenv()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n\n// ...\n\nconst char* dstr = std::getenv(\"TRITONSERVER_DELAY_SCHEDULER\");\nif (dstr == nullptr) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7382d71f-eb28-3153-993c-e47f567b67e8",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to ensure the source pointer is non-null, which increases the risk of a null pointer dereference. The destination is a pointer type with no known capacity, and the size argument is not derived from the destination's size, making it difficult to guarantee safe copying. These factors together indicate a real risk of undefined behavior and potential security issues.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(corrid_p_ptr, corrid_ptr, size_p);\n```\n\nAdditionally, ensure that both `corrid_p_ptr` and `corrid_ptr` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (corrid_p_ptr != nullptr && corrid_ptr != nullptr) {\n    memmove(corrid_p_ptr, corrid_ptr, size_p);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "687e447d-3dfe-33e3-bd82-7fd2bf1a0ec9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to a character buffer, and the source is the address of a variable, but dataflow analysis suggests that the destination and source may refer to overlapping memory. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the destination buffer is large enough to safely receive the copied data. These factors indicate a real risk of memory corruption or program crashes.\n\n## In Context Remediation\nTo remediate the undefined behavior risk caused by possible overlapping memory regions in the memory copy operation, ensure that the source and destination do not overlap. If there is any chance of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, verify that both pointers are valid and not null before performing the copy. For example:\n\n```cpp\nif (corrid_p_ptr != nullptr && &correlation_id_length != nullptr) {\n    memmove(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t));\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and add assertions to enforce it:\n\n```cpp\nassert(corrid_p_ptr != &correlation_id_length);\nmemcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6ba914c8-33fb-3221-9191-086793687d29",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and neither the source nor the destination is null at the call site, which means the operation will proceed if overlap occurs. The destination is a pointer with no known capacity, and the count argument is not directly tied to the destination's size, increasing the risk. This combination of factors makes the issue actionable and not a false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(data_ptr, file_input.data(), total_byte_size);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4adefcee-b15d-3a16-a51d-63442f5be6f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a prohibited function because it does not perform any error checking and can lead to integer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For instance, instead of `atoi()`, you can use `strtol()` which allows you to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\nchar *end;\nlong int value = strtol(dstr, &end, 10);\nif (end == dstr || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    sched->backlog_delay_cnt_ = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `strtol()`)\n- `cerrno` (for `errno`)\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [OWASP Proactive Controls](https://owasp.org/www-project-proactive-controls/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1d1a0a32-a161-3a86-a43e-7b65df84652a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities as it returns a pointer to the value of the environment variable, which can be modified by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv` function directly in your code. If you need to use environment variables, consider using a safer alternative that validates the input and ensures it cannot be manipulated by an attacker. \n\n## Source Code Fix Recommendation\n\nInstead of directly using `getenv`, consider using a safer alternative. Here is an example of how you can do this:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nchar* safe_getenv(const char* name) {\n    static char value[1024];\n    char* temp = getenv(name);\n    if (temp != NULL) {\n        strncpy(value, temp, sizeof(value) - 1);\n        value[sizeof(value) - 1] = '\\0';\n        return value;\n    }\n    return NULL;\n}\n\n// Usage\ndstr = safe_getenv(\"TRITONSERVER_BACKLOG_DELAY_SCHEDULER\");\n```\n\nIn this code, `safe_getenv` function is used to safely get the value of an environment variable. It copies the value into a local buffer, ensuring that it cannot be modified by an attacker.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cstring\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2c62cf30-418f-3e38-a621-716c3227a362",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using `atoi()` function as it does not check for errors. It is recommended to use safer alternatives such as `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for strtol\n#include <climits> // for LONG_MAX and LONG_MIN\n#include <cerrno>  // for errno\n\nchar *end;\nlong delay_cnt = strtol(dstr, &end, 10);\n\nif (end == dstr) {\n    // dstr is empty or invalid number\n} else if ((delay_cnt == LONG_MAX || delay_cnt == LONG_MIN) && errno == ERANGE) {\n    // delay_cnt is out of range\n} else {\n    // delay_cnt is valid\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e0c2022c-e5f0-365f-82bb-e9b7dd3ad564",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the function `getenv()` is used, which can lead to security vulnerabilities as it allows access to the environment variables of the process. An attacker could potentially manipulate these variables to influence the program behavior.\n\n## Mitigation Advice\n\nAvoid using functions that can lead to security vulnerabilities. In this case, consider using a safer alternative to `getenv()`. If you must use `getenv()`, ensure that the environment in which your application runs is secure and that environment variables cannot be manipulated by untrusted users.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your application. If you need to access an environment variable, you could consider using a safer alternative like `std::getenv()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n\n// ...\n\nconst char* dstr = std::getenv(\"TRITONSERVER_DELAY_SCHEDULER\");\nif (dstr == nullptr) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "76feaaa9-c9ba-362c-8356-7148e7911686",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability in C++ is a security flaw that occurs when a program does not validate or incorrectly validates an URL before loading it. This can lead to various attacks such as phishing, URL redirection to untrusted sites, and remote code execution. The vulnerability is not specific to the C++ language but can occur in any programming language that deals with URLs.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate URLs before using them. This includes checking the scheme (http, https, ftp, etc.), the domain, and the path. \n\n2. Use a whitelist of trusted URLs and only allow redirections or connections to these URLs.\n\n3. Avoid using user input directly in URLs. If this is unavoidable, make sure to properly sanitize and encode the input.\n\n4. Use secure libraries or functions that handle URLs correctly.\n\n## Source Code Fix Recommendation\n\nThe following is a simple example of how to validate a URL using the `Poco::URI` class from the Poco C++ Libraries:\n\n```cpp\n#include <Poco/URI.h>\n\nbool isValidUrl(const std::string& url) {\n    try {\n        Poco::URI uri(url);\n        return uri.getScheme() == \"http\" || uri.getScheme() == \"https\";\n    } catch (Poco::Exception&) {\n        return false;\n    }\n}\n```\n\nIn this example, the `isValidUrl` function checks if the URL has a valid scheme (http or https). If the URL is invalid or has a different scheme, the function returns false.\n\n## Library Dependencies\n\nThe above code example requires the Poco C++ Libraries. Specifically, it uses the `Poco::URI` class from the `Poco::Net` module.\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "4d609d23-c614-31db-9802-5278d44cd551",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer over-read, information leakage, or even a segmentation fault.\n\nIn the provided code snippet, the `strlen` function is used to calculate the length of a constant string `\"http://\"` which is safe. However, if the `strlen` function is used elsewhere in the code with user-controlled input or non-null-terminated strings, it could lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. Avoid using `strlen` with user-controlled input where possible. If you need to use `strlen` with user-controlled input, ensure that the input is properly sanitized and null-terminated.\n\n## Source Code Fix Recommendation\n\nThe provided code snippet is safe as it uses `strlen` with a constant string. However, if `strlen` is used elsewhere in the code with user-controlled input, it could be replaced with `strnlen` which takes an additional parameter specifying the maximum length of the string to be considered.\n\n```cpp\nsize_t len = strnlen(user_input, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<string>`: for `std::string` and `std::string::substr`\n- `<cstring>`: for `strlen`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a905777a-845c-38e1-84d3-e92baf0a2c2a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` can continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding one before using `strlen`.\n\nIn addition, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`. This function will stop reading memory after a certain number of characters, even if it doesn't encounter a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used correctly and does not pose a vulnerability. The function is called with a string literal (\"https://\"), which is always null-terminated in C and C++. However, if the string were to come from an untrusted source, it would be safer to use `strnlen`:\n\n```cpp\npath = path.substr(https_start + strnlen(\"https://\", 8));\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<string>`: for the `std::string` class and its `substr` method.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "407715cc-1859-38c2-bf37-c22ec0e637fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not perform any bounds checking. This means that if the string is not null-terminated, `strlen` will continue reading until it encounters a null character, potentially leading to a buffer overflow. This can result in undefined behavior, including program crashes, incorrect results, and security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using `strlen` and similar functions that do not perform bounds checking. Instead, consider using safer alternatives that do perform bounds checking, such as `strnlen` or `std::string::length`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used to calculate the length of a constant string. This is not a vulnerability, because the length of the string is known at compile time and does not depend on user input. However, to follow best practices and avoid potential issues in the future, you could replace `strlen` with `sizeof`:\n\n```cpp\npath = s3_path.substr(start + sizeof(\"s3://\") - 1)\n```\n\nNote that `sizeof` returns the size in bytes, including the null terminator, so we subtract 1 to get the length of the string.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `<string>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "5bf932df-a03d-351a-9dd8-67c4e93ac001",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This can lead to buffer overflows if the string is not properly null-terminated, which can in turn lead to arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include length checks, such as `strnlen` or `strncpy`. These functions take an additional parameter that specifies the maximum length of the string, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nThe following code snippet shows how to fix the vulnerability:\n\n```cpp\nstd::string s3_prefix = \"s3://\";\nbucket_start = clean_path.find(s3_prefix) + s3_prefix.length();\n```\n\nIn this code, the `length` method of the `std::string` class is used instead of `strlen`. This method returns the number of characters in the string, and it is safe because it does not rely on null termination.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "02b97741-a1fd-3efb-8bfb-0e64e919819b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The problem is that the returned pointer might be invalidated or the associated string might be overwritten by another call to `getenv`.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, consider using safer alternatives that are less prone to security issues. If you must use `std::getenv`, ensure that the returned pointer is not directly exposed to the user or used in security-sensitive contexts. Also, be aware that the string returned by `std::getenv` can be overwritten by subsequent calls to `getenv`, `setenv`, or `putenv`.\n\n## Source Code Fix Recommendation\n\nInstead of using `std::getenv`, you can use a safer alternative. For example, you can use the `std::getenv_s` function, which is safer because it checks the size of the buffer to prevent buffer overflow attacks.\n\n```cpp\nchar* buffer;\nsize_t bufferSize;\n_getenv_s(&bufferSize, NULL, 0, \"AWS_PROFILE\");\nbuffer = new char[bufferSize];\n_getenv_s(&bufferSize, buffer, bufferSize, \"AWS_PROFILE\");\nstd::string profile(buffer);\ndelete[] buffer;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This library is required for the `std::getenv` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d5ef4825-8a75-3925-9720-02a88e901568",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `std::getenv` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned pointer might get invalidated or the associated string might get overwritten by another call to `getenv`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a secure method to retrieve environment variables. \n\n## Source Code Fix Recommendation\n\n```cpp\nchar* secure_getenv(const char* name) {\n    if (getuid() == geteuid() && getgid() == getegid()) {\n        return getenv(name);\n    } else {\n        // Environment variable cannot be securely obtained\n        return NULL;\n    }\n}\n\n// Usage\nchar* session_token = secure_getenv(\"AWS_SESSION_TOKEN\");\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `std::getenv`)\n- `unistd.h` (for `getuid`, `geteuid`, `getgid`, `getegid`)\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1f006cd3-211c-31c8-b946-ba57cd2fa7b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The problem is that the returned pointer might be invalidated or the associated string might be overwritten by another call to `getenv`, `setenv`, `putenv`, `unsetenv`, `setlocale`, or by an operation that modifies the environment. Therefore, the string should be copied immediately.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `std::getenv` function. Instead, use safer alternatives that do not have these issues. If you must use `std::getenv`, ensure that you immediately copy the returned string to a buffer that you control. This way, even if the original string is modified, your copy will remain valid.\n\n## Source Code Fix Recommendation\n\nHere is a safer way to use `std::getenv`:\n\n```cpp\nchar* value = std::getenv(\"AWS_DEFAULT_REGION\");\nif (value != nullptr) {\n    std::string region(value);\n}\n```\n\nIn this code, the value returned by `std::getenv` is immediately copied to a `std::string`. This ensures that even if the original value is modified, the copy in `region` remains valid.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdlib>`: This library provides general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "97b364b4-6f24-3b0d-b5e6-7897554f2e8e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In this case, the `std::getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned pointer might be invalidated or the associated string might be overwritten by a subsequent call to `std::getenv`, `std::setenv`, or `std::unsetenv`.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function directly. Instead, use secure alternatives that are less prone to vulnerabilities. Validate all inputs and outputs where possible. Avoid making security decisions based on the results of a call to `std::getenv`.\n\n## Source Code Fix Recommendation\n\nInstead of using `std::getenv`, consider using a more secure method to retrieve environment variables. Here is an example of how you can do this:\n\n```cpp\n#include <cstdlib>\n\nconst char* getEnvVar(const char* key) {\n    const char* val = std::getenv(key);\n    if (val == nullptr) {\n        // Handle the case where the environment variable doesn't exist.\n        return \"\";\n    }\n    return val;\n}\n\n// Usage\nstd::string key_id = getEnvVar(\"AWS_ACCESS_KEY_ID\");\n```\n\nIn this code, we have a function `getEnvVar` that wraps `std::getenv` and handles the case where the environment variable doesn't exist.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdlib>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "15e4df84-95fb-30a6-9184-fc73af412e0a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::getenv` function is used, which can lead to information disclosure or unauthorized actions.\n\n`std::getenv` is a function that retrieves the value of the environment variable passed as argument. The problem with `std::getenv` is that it returns a pointer to the value of the environment variable which can be modified by any function in the program, leading to potential security issues.\n\n## Mitigation Advice\n\nAvoid using `std::getenv` function. Instead, use secure alternatives that do not allow modification of the environment variable values. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\nconst char* getEnvVar(const std::string &key) {\n    char* val = std::getenv(key.c_str());\n    return val == NULL ? \"\" : val;\n}\n\nstd::string secret_key = getEnvVar(\"AWS_SECRET_ACCESS_KEY\");\n```\n\nIn this code, we have created a function `getEnvVar` that wraps the `std::getenv` function and returns a copy of the environment variable value instead of a pointer to it. This prevents any function from modifying the environment variable value.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This library provides general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "896888b6-602b-3089-9d23-65482d763221",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the observed alias assignment. Additionally, there is no explicit check to ensure that the source pointer is not null before the copy, which further increases the risk. The destination is guarded as non-null, but the source is not. The operation does not use a count based on the destination's capacity, and there are no explicit bounds or null-termination protections. These factors together indicate a real risk of undefined behavior and potential security issues.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy. For example:\n\n```cpp\nif (from_data_buffer != nullptr) {\n    std::memmove(data->MutableBuffer(), from_data_buffer, from_data_byte_size);\n}\n```\nThis change ensures that the copy operation is safe even if the memory regions overlap, and avoids dereferencing a null pointer.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "294574fc-8fcb-334a-89a5-113d6d0cc646",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "55595bef-349a-3332-bc59-a07ad1f30d97",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7689cf47-00d3-36d0-ab01-31245310b791",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e603d949-2a75-300b-9649-16595068de1b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to security breaches.\n\nThe `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm and can produce predictable numbers if the seed is known. This makes it unsuitable for generating random numbers in security-sensitive contexts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of `rand()`. In C++, you can use functions provided by libraries like `<random>` which offer a variety of stronger random number generators.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a stronger random number generator. Here is an example using the `std::random_device` and `std::mt19937` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(0, 255);\n\nrandom_buffer[offset] = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "a4ab95c5-8027-3cef-abff-4ba196323abe",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6da87f01-437d-37fa-9d7e-33b95a3c19e7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()`. Here is an example of how to use `strerror_r()`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    // handle error\n}\nstd::string errMsg = \"Failed to create directory '\" + dir + \"', errno: \" + buf;\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<string.h>` for `strerror_r()`\n- `<errno.h>` for `errno`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "75e7db96-c1f3-3ec0-9963-9003d3273db9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1f6f21be-5641-331d-b4d8-ebcbe139f2c8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` or `strerror_s()`. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()`. Here is an example of how to use `strerror_r()`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    // handle error\n}\nstd::string errorMsg = \"failed to open text file for write \" + path + \": \" + buf;\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<string.h>` for `strerror_r()`\n- `<errno.h>` for `errno`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d8acdefe-c78e-3f38-be95-8eb9260e913e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `strerror` function is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use thread-safe alternatives to these insecure C library functions. In the case of `strerror`, the thread-safe alternative is `strerror_r`.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r` as shown below:\n\n```cpp\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    // handle error\n}\nstd::string errMsg = \"failed to open text file for read \" + path + \": \" + buf;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: for `strerror_r` and `errno`\n- `<string>`: for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "0f0b9a5d-fa44-3798-b430-9b90a3587522",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/api.cc"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 37,
                  "endLine": 270,
                  "endColumn": 43,
                  "charOffset": 9712,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ac428da8-26f9-3120-8f65-d1c61ecedbdb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_manager.cc"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 9,
                  "endLine": 96,
                  "endColumn": 42,
                  "charOffset": 3550,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(new_base, base, byte_size)",
                    "rendered": {
                      "text": "memcpy(new_base, base, byte_size)",
                      "markdown": "`memcpy(new_base, base, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_manager.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3550,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_base, <size of new_base>,  base,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b1eea13c-2a23-36d4-a6ef-56eda3e97361",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_manager.cc"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 9,
                  "endLine": 144,
                  "endColumn": 68,
                  "charOffset": 5140,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(cache_buffer, buffers_[i].data(), cache_buffer_size)",
                    "rendered": {
                      "text": "memcpy(cache_buffer, buffers_[i].data(), cache_buffer_size)",
                      "markdown": "`memcpy(cache_buffer, buffers_[i].data(), cache_buffer_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_manager.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5140,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cache_buffer, <size of cache_buffer>,  buffers_[i].data(),  cache_buffer_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "17f13493-cac7-32e0-bef8-ea33b778356a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_manager.cc"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 21,
                  "endLine": 95,
                  "endColumn": 38,
                  "charOffset": 3522,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(byte_size)",
                    "rendered": {
                      "text": "malloc(byte_size)",
                      "markdown": "`malloc(byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_manager.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3522,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d5a8c098-59d3-3d1a-8f13-5584fb992669",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/tritonserver.cc"
                },
                "region": {
                  "startLine": 568,
                  "startColumn": 21,
                  "endLine": 568,
                  "endColumn": 34,
                  "charOffset": 17974,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(dtype)",
                    "rendered": {
                      "text": "strlen(dtype)",
                      "markdown": "`strlen(dtype)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/tritonserver.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17974,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(dtype, <size of dtype>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/tritonserver.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17974,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(dtype, <size of dtype>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a7c32d79-d161-3975-a0f8-fcf4e2823ab3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/as.h"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 33,
                  "endLine": 55,
                  "endColumn": 39,
                  "charOffset": 2300,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "247eb5c9-0dad-379e-9c46-f81d4136f23d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/as.h"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 33,
                  "endLine": 56,
                  "endColumn": 39,
                  "charOffset": 2366,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "47f78bec-7597-3cf5-ad83-75bdd6d1d4a3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/common.h"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 22,
                  "endLine": 123,
                  "endColumn": 28,
                  "charOffset": 4786,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4f3903aa-aff0-343e-86b6-b4065c27ad01",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cuda_utils.cc"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 6,
                  "endLine": 148,
                  "endColumn": 33,
                  "charOffset": 5035,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_size)",
                      "markdown": "`memcpy(dst, src, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cuda_utils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5035,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3abb514d-ffea-3c22-bab6-2b2809839c3c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/model_config_utils.cc"
                },
                "region": {
                  "startLine": 2059,
                  "startColumn": 15,
                  "endLine": 2059,
                  "endColumn": 20,
                  "charOffset": 72523,
                  "charLength": 5,
                  "snippet": {
                    "text": "atoll",
                    "rendered": {
                      "text": "atoll",
                      "markdown": "`atoll`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "768ee474-8462-3af4-af46-588e3407c16c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/model_config_utils.cc"
                },
                "region": {
                  "startLine": 2026,
                  "startColumn": 13,
                  "endLine": 2026,
                  "endColumn": 18,
                  "charOffset": 71691,
                  "charLength": 5,
                  "snippet": {
                    "text": "atoll",
                    "rendered": {
                      "text": "atoll",
                      "markdown": "`atoll`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e5b99c3c-cb9c-3d7f-a613-1e0590355146",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cuda_utils.cc"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 2,
                  "endLine": 44,
                  "endColumn": 71,
                  "charOffset": 1912,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)",
                    "rendered": {
                      "text": "memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)",
                      "markdown": "`memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cuda_utils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1912,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(copy_params->dst_, <size of copy_params->dst_>,  copy_params->src_,  copy_params->byte_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "423dab50-0843-3d87-981e-682835760399",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cuda_utils.cc"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 4,
                  "endLine": 151,
                  "endColumn": 31,
                  "charOffset": 5080,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_size)",
                      "markdown": "`memcpy(dst, src, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cuda_utils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5080,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "35a89f78-59a8-385d-be57-547aaf60e904",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/model_config_utils.cc"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 20,
                  "endLine": 458,
                  "endColumn": 25,
                  "charOffset": 15988,
                  "charLength": 5,
                  "snippet": {
                    "text": "atoll",
                    "rendered": {
                      "text": "atoll",
                      "markdown": "`atoll`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4cf5cf17-3707-35dc-86e5-3c50816fad30",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/metrics.cc"
                },
                "region": {
                  "startLine": 790,
                  "startColumn": 29,
                  "endLine": 790,
                  "endColumn": 38,
                  "charOffset": 28625,
                  "charLength": 9,
                  "snippet": {
                    "text": "127.0.0.1",
                    "rendered": {
                      "text": "127.0.0.1",
                      "markdown": "`127.0.0.1`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "c1262fae-3866-3816-952c-00b6660ac02b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 2,
                  "endLine": 481,
                  "endColumn": 77,
                  "charOffset": 15205,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&output_byte_size, packed_bytes.begin() + position, sizeof(uint64_t)",
                    "rendered": {
                      "text": "memcpy(&output_byte_size, packed_bytes.begin() + position, sizeof(uint64_t)",
                      "markdown": "`memcpy(&output_byte_size, packed_bytes.begin() + position, sizeof(uint64_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15205,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output_byte_size, <size of &output_byte_size>,  packed_bytes.begin() + position,  sizeof(uint64_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c6afa829-0e06-320e-bc08-eaba33ba960d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/metrics.cc"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 11,
                  "endLine": 339,
                  "endColumn": 17,
                  "charOffset": 13707,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "eefd14e7-3473-36dc-b594-c54371548437",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_model.cc"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 25,
                  "endLine": 560,
                  "endColumn": 31,
                  "charOffset": 20829,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8e4befe9-44eb-3173-bc42-1479b0cf4062",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 2,
                  "endLine": 476,
                  "endColumn": 72,
                  "charOffset": 15047,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(shape.data(), packed_bytes.begin() + position, shape_byte_size)",
                    "rendered": {
                      "text": "memcpy(shape.data(), packed_bytes.begin() + position, shape_byte_size)",
                      "markdown": "`memcpy(shape.data(), packed_bytes.begin() + position, shape_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15047,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(shape.data(), <size of shape.data()>,  packed_bytes.begin() + position,  shape_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b5dda9af-9cf3-3e32-afa0-08dc5fb06369",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 472,
                  "startColumn": 2,
                  "endLine": 472,
                  "endColumn": 76,
                  "charOffset": 14867,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(&shape_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(&shape_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                      "markdown": "`memcpy(&shape_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14867,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&shape_byte_size, <size of &shape_byte_size>,  packed_bytes.begin() + position,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "647fa7b4-45fb-375c-bf40-0ed7c47ef84e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 2,
                  "endLine": 454,
                  "endColumn": 75,
                  "charOffset": 14262,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(&name_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(&name_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                      "markdown": "`memcpy(&name_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14262,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&name_byte_size, <size of &name_byte_size>,  packed_bytes.begin() + position,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d8b6581e-3d77-348c-b036-21405f882b9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 2,
                  "endLine": 463,
                  "endColumn": 76,
                  "charOffset": 14561,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(&dtype_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(&dtype_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)",
                      "markdown": "`memcpy(&dtype_byte_size, packed_bytes.begin() + position, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14561,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dtype_byte_size, <size of &dtype_byte_size>,  packed_bytes.begin() + position,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "29bd8595-b1ce-3a8c-acf7-8c4a0937ccb5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 374,
                  "startColumn": 4,
                  "endLine": 374,
                  "endColumn": 72,
                  "charOffset": 11903,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(output_buffer, cache_output.buffer_, cache_output.byte_size_)",
                    "rendered": {
                      "text": "memcpy(output_buffer, cache_output.buffer_, cache_output.byte_size_)",
                      "markdown": "`memcpy(output_buffer, cache_output.buffer_, cache_output.byte_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11903,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(output_buffer, <size of output_buffer>,  cache_output.buffer_,  cache_output.byte_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3daacc22-6872-3335-bbcc-052bb7f2cf5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 9,
                  "endLine": 332,
                  "endColumn": 72,
                  "charOffset": 10407,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(\n        &packed_output_size, base + position, sizeof(packed_output_size)",
                    "rendered": {
                      "text": "memcpy(\n        &packed_output_size, base + position, sizeof(packed_output_size)",
                      "markdown": "`memcpy(\n        &packed_output_size, base + position, sizeof(packed_output_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10407,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n        &packed_output_size, <size of \n        &packed_output_size>,  base + position,  sizeof(packed_output_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0e0cc587-b1f9-39ec-8e5f-ea490eae15f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 7,
                  "endLine": 324,
                  "endColumn": 53,
                  "charOffset": 10197,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(&num_outputs, base, sizeof(num_outputs)",
                    "rendered": {
                      "text": "memcpy(&num_outputs, base, sizeof(num_outputs)",
                      "markdown": "`memcpy(&num_outputs, base, sizeof(num_outputs)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10197,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&num_outputs, <size of &num_outputs>,  base,  sizeof(num_outputs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d9a1e8fd-53e2-3bda-9ef9-e7c581c51bc2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 282,
                  "startColumn": 2,
                  "endLine": 282,
                  "endColumn": 62,
                  "charOffset": 9014,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(buffer + position, output_base, u64_output_byte_size)",
                    "rendered": {
                      "text": "memcpy(buffer + position, output_base, u64_output_byte_size)",
                      "markdown": "`memcpy(buffer + position, output_base, u64_output_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9014,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  output_base,  u64_output_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ff0d165a-b7ba-3fdb-bb8d-8d4db2e45c5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 2,
                  "endLine": 280,
                  "endColumn": 67,
                  "charOffset": 8912,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(buffer + position, &u64_output_byte_size, sizeof(uint64_t)",
                    "rendered": {
                      "text": "memcpy(buffer + position, &u64_output_byte_size, sizeof(uint64_t)",
                      "markdown": "`memcpy(buffer + position, &u64_output_byte_size, sizeof(uint64_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8912,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  &u64_output_byte_size,  sizeof(uint64_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "43d98d3a-a370-339c-ab19-f30719a6bcdc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 2,
                  "endLine": 276,
                  "endColumn": 58,
                  "charOffset": 8792,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(buffer + position, shape.data(), shape_byte_size)",
                    "rendered": {
                      "text": "memcpy(buffer + position, shape.data(), shape_byte_size)",
                      "markdown": "`memcpy(buffer + position, shape.data(), shape_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8792,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  shape.data(),  shape_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "43a67c7f-e15f-35fb-8b54-8b664164a473",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 274,
                  "startColumn": 2,
                  "endLine": 274,
                  "endColumn": 62,
                  "charOffset": 8695,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(buffer + position, &shape_byte_size, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(buffer + position, &shape_byte_size, sizeof(uint32_t)",
                      "markdown": "`memcpy(buffer + position, &shape_byte_size, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8695,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  &shape_byte_size,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "37906f89-1e7c-31d5-a8ba-66718f028ac6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 268,
                  "startColumn": 2,
                  "endLine": 268,
                  "endColumn": 62,
                  "charOffset": 8494,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(buffer + position, &dtype_byte_size, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(buffer + position, &dtype_byte_size, sizeof(uint32_t)",
                      "markdown": "`memcpy(buffer + position, &dtype_byte_size, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8494,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  &dtype_byte_size,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "935e479b-81ac-3824-8f05-587643c1b22e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 262,
                  "startColumn": 2,
                  "endLine": 262,
                  "endColumn": 61,
                  "charOffset": 8297,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(buffer + position, &name_byte_size, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(buffer + position, &name_byte_size, sizeof(uint32_t)",
                      "markdown": "`memcpy(buffer + position, &name_byte_size, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8297,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  &name_byte_size,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e15baff6-b7ee-378e-a25f-0fb03c347845",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 2,
                  "endLine": 258,
                  "endColumn": 62,
                  "charOffset": 8189,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(buffer + position, &total_byte_size, sizeof(uint64_t)",
                    "rendered": {
                      "text": "memcpy(buffer + position, &total_byte_size, sizeof(uint64_t)",
                      "markdown": "`memcpy(buffer + position, &total_byte_size, sizeof(uint64_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8189,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer + position, <size of buffer + position>,  &total_byte_size,  sizeof(uint64_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "268fe16b-c065-3049-bd96-5c4a95b535b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cache_entry.cc"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 7,
                  "endLine": 171,
                  "endColumn": 50,
                  "charOffset": 5347,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(base, &num_outputs, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(base, &num_outputs, sizeof(uint32_t)",
                      "markdown": "`memcpy(base, &num_outputs, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cache_entry.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5347,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(base, <size of base>,  &num_outputs,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ee4a4bc5-8bac-376f-b1cf-830b27ac4e47",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_state.cc"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 8,
                  "endLine": 209,
                  "endColumn": 59,
                  "charOffset": 7731,
                  "charLength": 113,
                  "snippet": {
                    "text": "memcpy(\n            dst_buffer, initial_state_buffer,\n            initial_state_it->second.data_->TotalByteSize()",
                    "rendered": {
                      "text": "memcpy(\n            dst_buffer, initial_state_buffer,\n            initial_state_it->second.data_->TotalByteSize()",
                      "markdown": "`memcpy(\n            dst_buffer, initial_state_buffer,\n            initial_state_it->second.data_->TotalByteSize()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_state.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7731,
                        "charLength": 113
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n            dst_buffer, <size of \n            dst_buffer>,  initial_state_buffer, \n            initial_state_it->second.data_->TotalByteSize()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f7383f15-545d-3fda-b8a1-dbdaf8a69f67",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/gcs.h"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 42,
                  "endLine": 141,
                  "endColumn": 57,
                  "charOffset": 5317,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(\"gs://\")",
                    "rendered": {
                      "text": "strlen(\"gs://\")",
                      "markdown": "`strlen(\"gs://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/gcs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5317,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"gs://\", <size of \"gs://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/gcs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5317,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(\"gs://\", <size of \"gs://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "316ba1ed-468f-3afb-823e-138611db3b0c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/gcs.h"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 26,
                  "endLine": 45,
                  "endColumn": 32,
                  "charOffset": 1934,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6dd3286c-fb15-37f0-bf22-4ee147ae99e3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1568,
                  "startColumn": 16,
                  "endLine": 1568,
                  "endColumn": 20,
                  "charOffset": 59049,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4fcab61e-7d1f-3e2b-882a-c9bc956dd491",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1565,
                  "startColumn": 21,
                  "endLine": 1565,
                  "endColumn": 27,
                  "charOffset": 58944,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7382d71f-eb28-3153-993c-e47f567b67e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1388,
                  "startColumn": 6,
                  "endLine": 1388,
                  "endColumn": 46,
                  "charOffset": 52925,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(corrid_p_ptr, corrid_ptr, size_p)",
                    "rendered": {
                      "text": "memcpy(corrid_p_ptr, corrid_ptr, size_p)",
                      "markdown": "`memcpy(corrid_p_ptr, corrid_ptr, size_p)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52925,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(corrid_p_ptr, <size of corrid_p_ptr>,  corrid_ptr,  size_p)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "687e447d-3dfe-33e3-bd82-7fd2bf1a0ec9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 1380,
                  "startColumn": 6,
                  "endLine": 1380,
                  "endColumn": 67,
                  "charOffset": 52511,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)",
                      "markdown": "`memcpy(corrid_p_ptr, &correlation_id_length, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52511,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(corrid_p_ptr, <size of corrid_p_ptr>,  &correlation_id_length,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6ba914c8-33fb-3221-9191-086793687d29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 459,
                  "startColumn": 6,
                  "endLine": 459,
                  "endColumn": 58,
                  "charOffset": 16356,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(data_ptr, file_input.data(), total_byte_size)",
                    "rendered": {
                      "text": "memcpy(data_ptr, file_input.data(), total_byte_size)",
                      "markdown": "`memcpy(data_ptr, file_input.data(), total_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16356,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data_ptr, <size of data_ptr>,  file_input.data(),  total_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4adefcee-b15d-3a16-a51d-63442f5be6f8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 32,
                  "endLine": 116,
                  "endColumn": 36,
                  "charOffset": 3948,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1d1a0a32-a161-3a86-a43e-7b65df84652a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/sequence_batch_scheduler/sequence_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 21,
                  "endLine": 113,
                  "endColumn": 27,
                  "charOffset": 3810,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2c62cf30-418f-3e38-a621-716c3227a362",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/dynamic_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 323,
                  "startColumn": 18,
                  "endLine": 323,
                  "endColumn": 22,
                  "charOffset": 12372,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e0c2022c-e5f0-365f-82bb-e9b7dd3ad564",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/dynamic_batch_scheduler.cc"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 23,
                  "endLine": 321,
                  "endColumn": 29,
                  "charOffset": 12287,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "76feaaa9-c9ba-362c-8356-7148e7911686",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 17,
                  "endLine": 276,
                  "endColumn": 31,
                  "charOffset": 10202,
                  "charLength": 14,
                  "snippet": {
                    "text": "http://|https:",
                    "rendered": {
                      "text": "http://|https:",
                      "markdown": "`http://|https:`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10202,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "https://|https:"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "4d609d23-c614-31db-9802-5278d44cd551",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 38,
                  "endLine": 235,
                  "endColumn": 55,
                  "charOffset": 9095,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(\"http://\")",
                    "rendered": {
                      "text": "strlen(\"http://\")",
                      "markdown": "`strlen(\"http://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9095,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"http://\", <size of \"http://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9095,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(\"http://\", <size of \"http://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a905777a-845c-38e1-84d3-e92baf0a2c2a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 37,
                  "endLine": 230,
                  "endColumn": 55,
                  "charOffset": 8905,
                  "charLength": 18,
                  "snippet": {
                    "text": "strlen(\"https://\")",
                    "rendered": {
                      "text": "strlen(\"https://\")",
                      "markdown": "`strlen(\"https://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8905,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"https://\", <size of \"https://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8905,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "strnlen(\"https://\", <size of \"https://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "407715cc-1859-38c2-bf37-c22ec0e637fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 34,
                  "endLine": 220,
                  "endColumn": 49,
                  "charOffset": 8622,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(\"s3://\")",
                    "rendered": {
                      "text": "strlen(\"s3://\")",
                      "markdown": "`strlen(\"s3://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8622,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"s3://\", <size of \"s3://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8622,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(\"s3://\", <size of \"s3://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5bf932df-a03d-351a-9dd8-67c4e93ac001",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 50,
                  "endLine": 187,
                  "endColumn": 65,
                  "charOffset": 7681,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(\"s3://\")",
                    "rendered": {
                      "text": "strlen(\"s3://\")",
                      "markdown": "`strlen(\"s3://\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7681,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"s3://\", <size of \"s3://\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/filesystem/implementations/s3.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7681,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(\"s3://\", <size of \"s3://\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "02b97741-a1fd-3efb-8bfb-0e64e919819b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 29,
                  "endLine": 113,
                  "endColumn": 35,
                  "charOffset": 4692,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d5ef4825-8a75-3925-9720-02a88e901568",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 35,
                  "endLine": 112,
                  "endColumn": 41,
                  "charOffset": 4634,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1f006cd3-211c-31c8-b946-ba57cd2fa7b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 28,
                  "endLine": 111,
                  "endColumn": 34,
                  "charOffset": 4569,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "97b364b4-6f24-3b0d-b5e6-7897554f2e8e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 28,
                  "endLine": 110,
                  "endColumn": 34,
                  "charOffset": 4512,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "15e4df84-95fb-30a6-9184-fc73af412e0a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/s3.h"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 32,
                  "endLine": 109,
                  "endColumn": 38,
                  "charOffset": 4451,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "896888b6-602b-3089-9d23-65482d763221",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/infer_request.cc"
                },
                "region": {
                  "startLine": 557,
                  "startColumn": 9,
                  "endLine": 557,
                  "endColumn": 77,
                  "charOffset": 18833,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(data->MutableBuffer(), from_data_buffer, from_data_byte_size)",
                    "rendered": {
                      "text": "memcpy(data->MutableBuffer(), from_data_buffer, from_data_byte_size)",
                      "markdown": "`memcpy(data->MutableBuffer(), from_data_buffer, from_data_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/infer_request.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18833,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data->MutableBuffer(), <size of data->MutableBuffer()>,  from_data_buffer,  from_data_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "294574fc-8fcb-334a-89a5-113d6d0cc646",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/numa_utils.cc"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 14,
                  "endLine": 230,
                  "endColumn": 22,
                  "charOffset": 7210,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "55595bef-349a-3332-bc59-a07ad1f30d97",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/numa_utils.cc"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 62,
                  "endLine": 162,
                  "endColumn": 70,
                  "charOffset": 4836,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7689cf47-00d3-36d0-ab01-31245310b791",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/numa_utils.cc"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 12,
                  "endLine": 151,
                  "endColumn": 20,
                  "charOffset": 4571,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e603d949-2a75-300b-9649-16595068de1b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_model_instance.cc"
                },
                "region": {
                  "startLine": 428,
                  "startColumn": 30,
                  "endLine": 428,
                  "endColumn": 35,
                  "charOffset": 16884,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "a4ab95c5-8027-3cef-abff-4ba196323abe",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/numa_utils.cc"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 62,
                  "endLine": 135,
                  "endColumn": 70,
                  "charOffset": 4194,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6da87f01-437d-37fa-9d7e-33b95a3c19e7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/local.h"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 63,
                  "endLine": 276,
                  "endColumn": 71,
                  "charOffset": 8413,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "75e7db96-c1f3-3ec0-9963-9003d3273db9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/local.h"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 25,
                  "endLine": 328,
                  "endColumn": 33,
                  "charOffset": 10436,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1f6f21be-5641-331d-b4d8-ebcbe139f2c8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/local.h"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 62,
                  "endLine": 224,
                  "endColumn": 70,
                  "charOffset": 7006,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d8acdefe-c78e-3f38-be95-8eb9260e913e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/filesystem/implementations/local.h"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 61,
                  "endLine": 194,
                  "endColumn": 69,
                  "charOffset": 6218,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}